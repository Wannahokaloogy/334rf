#pragma config(Sensor, dgtl2,  ,               sensorTouch)
#pragma config(Sensor, dgtl3,  ,               sensorTouch)
#pragma config(Sensor, dgtl7,  solenoid2,      sensorDigitalOut)
#pragma config(Sensor, dgtl8,  solenoid1,      sensorDigitalOut)
#pragma config(Sensor, dgtl9,  LeftSpeed,      sensorQuadEncoder)
#pragma config(Sensor, dgtl11, RightSpeed,     sensorQuadEncoder)
#pragma config(Motor,  port1,           Intake1,       tmotorVex393HighSpeed_HBridge, openLoop)
#pragma config(Motor,  port2,           LauncherLB,    tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           LauncherLF,    tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           FLD,           tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port5,           BRD,           tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port6,           FRD,           tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port7,           BLD,           tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port8,           LauncherRF,    tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           LauncherRB,    tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          Intake2,       tmotorVex393HighSpeed_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"

////////////////////////////////////////////////////////////////////////////////////////////////////
//INTEGERS/////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
int power = 0;


int mid = 170;
int close =  120;
int full = 201 ;
int off = 0;
int IntakeRun = 0;

float velosityL;
float velosityR;

float kp = 0.01;
float ki = 0.01;
float kd = 0.01;

float currentL;								//yes I know they can be moved back to local when were done debugging.
float currentR;

float integralActiveZone = 20;
float errorTl;
float errorTr;
float lastErrorL;
float lastErrorR;
float proportionL;
float proportionR;
float integralL;
float integralR;
float derivativeL;
float derivativeR;

int X2 = 0, Y1 = 0, X1 = 0, threshold = 15; //deadzone threshold

int MVR; // Motor Velocity right
int MVL;

void Pnumatics() //brake
{
	if(vexRT[Btn6U] == 1)
	{
		SensorValue[solenoid1] = 1;
		SensorValue[solenoid2] = 1;
	}
	else if(vexRT[Btn6UXmtr2] == 1)
	{
		SensorValue[solenoid1] = 1;
		SensorValue[solenoid2] = 1;
	}
	else
	{
		SensorValue[solenoid1] = 0;
		SensorValue[solenoid2] = 0;
	}
}


void Drive()//thresholds keep motor whine at bay
{
	if(abs(vexRT[Ch4]) > threshold)
		X1 = -vexRT[Ch4];
	else
		X1 = 0;

	if(abs(vexRT[Ch1]) > threshold)
		X2 = -vexRT[Ch1];
	else
		X2 = 0;

	if(abs(vexRT[Ch3]) > threshold)
		Y1 = -vexRT[Ch3];
	else
		Y1 = 0;

	motor[FRD] = (Y1) - (X2) - (X1);
	motor[BRD] =  (Y1) - (X2) + (X1);
	motor[FLD] = (Y1) + (X2) + (X1);
	motor[BLD] =  (Y1) + (X2) - (X1);
}

void velocity()
{
	if(time1(T1) > 200)
	{
		velosityL = SensorValue[RightSpeed];
		velosityR = SensorValue[LeftSpeed];
		resetTimer(T1);
		SensorValue[RightSpeed]= 0;
		SensorValue[LeftSpeed]= 0;
	}
}

task Pid(){


	while(true)
	{
		velocity();

		float errorL = power - velosityL;
		float errorR = power - velosityR;
		//////////////////////////
		if(errorL <integralActiveZone && errorL != 0)
			errorTl += errorL;
		else
			errorTl = 0;

		if(errorR<integralActiveZone && errorR != 0)
			errorTr += errorR;
		else
			errorTr = 0;

		///////////////////////
		if(errorTl > 50/ki)
			errorTl = 50/ki;

		if(errorTr > 50/ki)
			errorTr = 50/ki;

		////////////////////////////
		if(errorL == 0)
			derivativeL = 0;

		if(errorR == 0)
			derivativeR = 0;
		////////////////////////////
		proportionL =errorL*kp;
		proportionR =errorR*kp;

		integralL = errorTl*ki;
		integralR = errorTr*ki;

		derivativeL = (errorL - lastErrorL)*kd;
		derivativeR = (errorR - lastErrorR)*kd;

		lastErrorL= errorL;
		lastErrorR= errorR;
		/////////////////////////

		currentL = proportionL + integralL + derivativeL;
		currentR = proportionR + integralR + derivativeR;

		motor[LauncherLB] = motor[LauncherLF] = currentL;
		motor[LauncherRB] = motor[LauncherRF] = currentR;

		wait1Msec(20);
	}
}

task SpeedControls()
{
	while(true){

		if(vexRT[Btn8U] == 1)
		{
			power = full;
		}
		if(vexRT[Btn8D] == 1)
		{
			power = off;
		}
		if(vexRT[Btn8R] == 1)
		{
			power = close;
		}
		if(vexRT[Btn8L] == 1)
		{
			power = mid;
		}

		if(vexRT[Btn7D] == 1)
		{
		}

		if(vexRT[Btn7U] == 1)
		{
		}
		//////////////////////////
		if(vexRT[Btn8UXmtr2] == 1)
		{
		}
		if(vexRT[Btn8DXmtr2] == 1)
		{
		}
		if(vexRT[Btn8RXmtr2] == 1)
		{
		}
		if(vexRT[Btn8LXmtr2] == 1)
		{
		}

		if(vexRT[Btn7DXmtr2] == 1)
		{
		}

		if(vexRT[Btn7UXmtr2] == 1)
		{
		}
		/////////////////////////

		wait1Msec(20);
	}
}


void Intake()
{
	if(vexRT[Btn5U] == 1)
	{
		motor[Intake2] = 127;
		motor[Intake1] = 127;
	}
	else if(vexRT[Btn5D] == 1)
	{
		motor[Intake2] = -127;
		motor[Intake1] = -127;
	}
	else if(vexRT[Btn5UXmtr2] == 1)
	{
		motor[Intake2] = 127;
		motor[Intake1] = 127;
	}
	else if(vexRT[Btn5DXmtr2] == 1)
	{
		motor[Intake2] = -127;
		motor[Intake1] = -127;
	}
	else
	{
		motor[Intake2] = 0;
		motor[Intake1] = 0;
	}

	if(vexRT[Btn7L] == 1)
	{
		IntakeRun = 1;
	}
	else if(vexRT[Btn7R] == 1)
	{
		IntakeRun = 0;
	}

	if (IntakeRun == 1)
	{
		motor[Intake2] = 127;
		motor[Intake1] = 127;
	}
}

////////////////////////////////////////////////////////////////////////////////////////////////////
//TASK CONTROL/////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////

void pre_auton() // this is where we can reset values/timers etc
{
	SensorValue[LeftSpeed] = 0;
	SensorValue[RightSpeed] = 0;
	resetTimer(T1);
	resetTimer(T2);
	resetTimer(T4);
}


//task autonomous() // main task basically, but this will run if we are put itno autonomous mode
//{
//	MVR = 77;
//	MVL = 77;
//	resetTimer(T2);
//	while (true)
//	{
//		change = full;
//		if (time1[T1]>200)
//		{
//			Speed();
//			resetTimer(T1);
//			SensorValue[LeftSpeed] = 0;
//			SensorValue[RightSpeed] = 0;
//			Pid();
//		}
//		change = full;
//		flyWheelRun();
//		if (time1[T2]>2000)
//		{
//			Staggershot();
//		}
//	}
//
//}

task usercontrol() // main task but for driver mode.
{
	while (true)
	{
		startTask(Pid);
		startTask(SpeedControls);
		Drive();
		Intake();
		flyWheelRun();
		Pnumatics();
	}
}
