#pragma config(Sensor, in1,    Bat2,           sensorAnalog)
#pragma config(Sensor, dgtl2,  BallIn,         sensorTouch)
#pragma config(Sensor, dgtl3,  BallOut,        sensorTouch)
#pragma config(Sensor, dgtl8,  solenoid,       sensorDigitalOut)
#pragma config(Sensor, dgtl9,  RightSpeed,     sensorQuadEncoder)
#pragma config(Sensor, dgtl11, LeftSpeed,      sensorQuadEncoder)
#pragma config(Motor,  port1,           FRD,           tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           BLD,           tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           LauncherR,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           LauncherRY,    tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           Intake1,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           Intake2,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           LauncherL,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           LauncherLY,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           BRD,           tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          FLD,           tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"

////////////////////////////////////////////////////////////////////////////////////////////////////
//INTEGERS/////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
int change = 0;


int mid = 95;
int close = 80 ;
int full = 111 ;
int intakerun = 0;


int rightSpeed,leftSpeed,lastRightSpeed,lastLeftSpeed;

int X2 = 0, Y1 = 0, X1 = 0, threshold = 15;

int Balls = 0;
int pause;

int MVR; // Motor Velocity right
int MVL;


void ball()   //counts balls... currently not used
{
	if (SensorValue[BallIn]== 1 && pause != 1)
	{
		Balls = Balls+1;
		pause = 1;
		if (pause == 1)
		{
			if (SensorValue[BallIn]!= 1)
				pause = 0;
		}
	}


	if (SensorValue[BallOut]== 1 && pause != 1)
	{
		Balls = Balls-1;
		pause = 1;
		if (pause == 1)
		{
			if (SensorValue[BallIn]!= 1)
				pause = 0;
		}
	}

}

void Pnumatics() //brake
{
	if(vexRT[Btn6U] == 1)
		SensorValue[solenoid] = 1;
	else if(vexRT[Btn6UXmtr2] == 1)
		SensorValue[solenoid] = 1;
	else
		SensorValue[solenoid] = 0;
}


void Drive()//thresholds keep motor whine at bay
{
	if(abs(vexRT[Ch4]) > threshold)
		X1 = -vexRT[Ch4];
	else
		X1 = 0;

	if(abs(vexRT[Ch1]) > threshold)
		X2 = vexRT[Ch1];
	else
		X2 = 0;

	if(abs(vexRT[Ch3]) > threshold)
		Y1 = -vexRT[Ch3];
	else
		Y1 = 0;

	motor[FRD] = Y1 - X2 - X1;
	motor[BRD] =  Y1 - X2 + X1;
	motor[FLD] = Y1 + X2 + X1;
	motor[BLD] =  Y1 + X2 - X1;
}

void flyWheelRun() // this updates our flywheel motor values to the actual motors
{
  motor[LauncherRY] = MVR;
	motor[LauncherR] = MVR;
	motor[LauncherL] = MVL;
	motor[LauncherLY] = MVL;
}

void Speed()// this runs after a timer is up to give us a spedometer
{
	lastLeftSpeed = leftSpeed;
	lastRightSpeed = rightSpeed;
	rightSpeed = SensorValue[RightSpeed];
	leftSpeed = SensorValue[LeftSpeed];
}


void Pid() //this is our code to make sure the flywheels keep the same speed
{
	if (rightSpeed < change )
		MVR=MVR+1;
	else if (rightSpeed > change && MVR > 0)
		MVR=MVR-1;
	else
		MVR= MVR;

	if (leftSpeed < change )
		MVL=MVL+1;
	else if (leftSpeed > change && MVL > 0)
		MVL=MVL-1;
else
	MVL= MVL;

}


void SpeedControls()
{

	if(vexRT[Btn8U] == 1)
	{
		change = full;
		MVR = 65;
		MVL = 65;
		wait1Msec(20);
	}
	if(vexRT[Btn8D] == 1)
	{
		change = 0;
		MVR = 0;
		MVL = 0;
		wait1Msec(20);
	}
	if(vexRT[Btn8R] == 1)
	{
		change = mid;
		MVR = 50;
		MVL = 50;
		wait1Msec(20);
	}
	if(vexRT[Btn8L] == 1)
	{
		change = close;
		MVR = 40;
		MVL = 40;
		wait1Msec(20);
	}

	if(vexRT[Btn7D] == 1)
	{
		if(MVR >=0)
		{
			change = change -1;
			wait1Msec(20);
		}
	}

	if(vexRT[Btn7U] == 1)
	{
		change = change +1;
		wait1Msec(20);
	}

}


void Intake()
{
	if(vexRT[Btn5U] == 1)
	{
		motor[Intake2] = 127;
		motor[Intake1] = 127;
	}
	else if(vexRT[Btn5D] == 1)
	{
		motor[Intake2] = -127;
		motor[Intake1] = -127;
	}
	else if(vexRT[Btn5UXmtr2] == 1)
	{
		motor[Intake2] = 127;
		motor[Intake1] = 127;
	}
	else if(vexRT[Btn5DXmtr2] == 1)
	{
		motor[Intake2] = -127;
		motor[Intake1] = -127;
	}
	else
	{
		motor[Intake2] = 0;
		motor[Intake1] = 0;
	}

	if(vexRT[Btn7L] == 1)
	{
		intakeRun = 1;
  }
  else if(vexRT[Btn7R] == 1)
	{
		intakeRun = 0;
  }

  if (intakerun == 1)
  {
  	motor[Intake2] = 127;
		motor[Intake1] = 127;
	}
}

void Staggershot() // autonomous function starts and stops the intake
{
if (time1(T3) > 1000)
{
	motor[Intake2] = 127;
	motor[Intake1] = 127;
}

if (time1(T4) > 1750)
	{
		motor[Intake2] = 0;
		motor[Intake1] = 0;
		resetTimer(T4);
		resetTimer(T3);
	}

}


void SpeedControls2()
{
	if(vexRT[Btn8UXmtr2] == 1)
	{
		change = full;
		MVR = 77;
		MVL = 77;
		wait1Msec(20);
	}
	if(vexRT[Btn7LXmtr2] == 1 || vexRT[Btn7RXmtr2] == 1)
	{
		change = 0;
		MVR = 0;
		MVL = 0;
		wait1Msec(20);
	}
	if(vexRT[Btn8RXmtr2] == 1 || vexRT[Btn8LXmtr2] == 1)
	{
		change = mid;
		MVR = 64;
		MVL = 64;
		wait1Msec(20);
	}
	if(vexRT[Btn8DXmtr2] == 1)
	{
		change = close;
		MVR = 58;
		MVL = 58;
		wait1Msec(20);
	}

	if(vexRT[Btn7DXmtr2] == 1)
	{
		if(MVR >=0)
		{
			change = change -1;
			wait1Msec(20);
		}
	}

	if(vexRT[Btn7UXmtr2] == 1)
	{
		change = change +1;
		wait1Msec(20);
	}

	if(vexRT[Btn7UXmtr2] == 1)
	{
		MVR = MVR+1;
		MVL = MVL+1;
		wait1Msec(200);
	}
}





////////////////////////////////////////////////////////////////////////////////////////////////////
//TASK CONTROL/////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////


void pre_auton() // this is where we can reset values/timers etc
{
	SensorValue[LeftSpeed] = 0;
	SensorValue[RightSpeed] = 0;
	resetTimer(T1);
	resetTimer(T2);
}


task autonomous() // main task basically, but this will run if we are put itno autonomous mode
{
		MVR = 77;
		MVL = 77;
		resetTimer(T2);
while (true)
	{
		change = full;
		if (time1[T1]>200)
		{
			Speed();
			resetTimer(T1);
			SensorValue[LeftSpeed] = 0;
			SensorValue[RightSpeed] = 0;
			Pid();
		}
		change = full;
		flyWheelRun();
		if (time1[T2]>2000)
		{
			Staggershot();
	}
	}

}

task usercontrol() // main task but for driver mode.
{
	while (true)
	{
		if (time1[T1]>200)
		{
			Speed();
			resetTimer();
			SensorValue[LeftSpeed] = 0;
			SensorValue[RightSpeed] = 0;
			Pid();
		}
		Drive();
		Intake();
		flyWheelRun();
		Pnumatics();
		SpeedControls();
		SpeedControls2();
	}
}
